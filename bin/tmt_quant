#!/usr/bin/env perl


use strict;
use warnings;
use 5.012;

use Data::Dumper;
use MS::Reader::MzML;
use MS::Reader::PepXML;
use MS::CV qw/:MS/;
use MS::Mass qw/elem_mass/;
use Getopt::Long;
use List::MoreUtils qw/uniq first_index/;
use List::Util qw/min max sum first any/;
use Math::Matrix;
use threads;
use threads::shared;
use Thread::Queue;
use Thread::Semaphore;
use Statistics::R;
use Statistics::Descriptive;

use constant PROTON => elem_mass('H');

our $VERSION = 0.010;

my $fn_tags;
my $correct_coelute = 0;
my $max_coelute     = 1;
my $reporter_tol    = 20;
my $pre_tol         = 10;
my $pre_shift       = 0;
my $fuzzy_edges     = 0;
my $scale_by_inj    = 0;
my $print_obs       = 0;
my $recal_reporters = 0;
my $plot_reporters;
my $sd_tol          = 3;
my $min_int         = 0;
my $min_matched     = 1;
my $threads         = 1;
my $decoy_tag       = 'REV_';
my $fn_impurities;
my $zero_floor;
my $filter_unlabeled;
my $digits;
my $subtract_baseline = 0;
my $q_cutoff;
my $fn_perc;

my @orig_argv = @ARGV;

GetOptions(
    'tags=s'            => \$fn_tags,
    'correct_coelute'   => \$correct_coelute,
    'max_coelute=f'     => \$max_coelute,
    'reporter_tol=f'    => \$reporter_tol,
    'pre_tol=f'         => \$pre_tol,
    'pre_shift=f'       => \$pre_shift,
    'fuzzy_edges'       => \$fuzzy_edges,
    'scale_by_inj'      => \$scale_by_inj,
    'output_obs'        => \$print_obs,
    'sd_tol=f'          => \$sd_tol,
    'recal_reporters'   => \$recal_reporters,
    'impurities=s'      => \$fn_impurities,
    'min_intensity=f'   => \$min_int,
    'threads=i'         => \$threads,
    'decoy_tag=s'       => \$decoy_tag,
    'zero_floor'        => \$zero_floor,
    'filter_unlabeled'  => \$filter_unlabeled,
    'digits=i'          => \$digits,
    'plot_reporters=s'  => \$plot_reporters,
    'min_matched=i'     => \$min_matched,
    'subtract_baseline' => \$subtract_baseline,
    'q-value'           => \$q_cutoff,
    'percolator'        => \$fn_perc,
) or die "Error parsing options\n";


my $pepxml :shared = $ARGV[-1];
my $px_parser = MS::Reader::PepXML->new($pepxml);
my $n_runs = $px_parser->n_lists();

die "Tag configuration file required" if (! defined $fn_tags);

# read in tag masses
my @reporters;
open my $tags, '<', $fn_tags or die "Error opening tags file: $!\n";
while (my $line = <$tags>) {
    chomp $line;
    my ($name, $mz) = split "\t", $line;
    die "Invalid tag file\n" if (! defined $mz);
    die "Invalid tag file\n" if ($mz !~ /^[\d\.]+$/);
    my $ref = { name => $name };
    for (0..$n_runs-1) {
        $ref->{$_}->{center} = $mz;
    }
    push @reporters, $ref;
}
close $tags;

my $REP_LOWER = min( map {$_->{0}->{center}} @reporters) - 1;
my $REP_UPPER = max( map {$_->{0}->{center}} @reporters) + 1;

for my $i (0..$#reporters) {
    my $tol = $recal_reporters ? $reporter_tol*3 : $reporter_tol;
    my $lower = $reporters[$i]->{0}->{center}*(1-$tol/1000000);
    my $upper = $reporters[$i]->{0}->{center}*(1+$tol/1000000);
  
    # make sure windows don't overlap
    if ($i > 0) {
        my $mid = (
            $reporters[$i-1]->{0}->{center}
          + $reporters[$i  ]->{0}->{center} ) / 2;
        $lower = $mid if ($lower < $mid);
    }
    if ($i < $#reporters) {
        my $mid = (
            $reporters[$i  ]->{0}->{center}
          + $reporters[$i+1]->{0}->{center} ) / 2;
        $upper = $mid if ($upper > $mid);
    }

    for (0..$n_runs-1) {
        $reporters[$i]->{$_}->{lower} = $lower;
        $reporters[$i]->{$_}->{upper} = $upper;
    }
}


warn "Windows for first scan:\n";
for my $rep (@reporters) {
    for my $run (0..$n_runs-1) {
        warn join( "\t",
            $rep->{name},
            "run $run",
            $rep->{$run}->{center},
            $rep->{$run}->{lower},
            $rep->{$run}->{upper},
        ) . "\n";
    }
}

# import isotope impurity matrix, if provided
my $impurities;
if (defined $fn_impurities) {
    open my $in, '<', $fn_impurities;
    my $h = <$in>;
    my @m;
    while (my $line = <$in>) {
        chomp $line;
        my @parts = split "\t", $line;
        shift @parts;
        push @m, [@parts];
    }
    $impurities = Math::Matrix->new( @m )->transpose;
}

# track reporter mass error for summary purposes
my @obs_mz  = map { {map {$_->{name} => []} @reporters} } 0..($n_runs-1);
my @obs_int = map { {map {$_->{name} => []} @reporters} } 0..($n_runs-1);
my $obs_mz  = shared_clone(\@obs_mz);
my $obs_int = shared_clone(\@obs_int);

my @channel_sums :shared = map {0} (0..$#reporters);

my @spectra :shared = ();

my $hit_queue = Thread::Queue->new();
my @workers;
for (1..$threads) {
    push @workers, threads->create(\&process_psm);
}

# load separate percolator table if given
my %qvals :shared = defined $fn_perc
    ? parse_percolator()
    : ();

load_queue();

# wait for all threads to finish
for (@workers) {
    $_->join();
}

# correct channel sums for impurities
if (defined $impurities) {
    my $uncorrected = Math::Matrix->new([@channel_sums]);
    my $a = $impurities->concat( $uncorrected->transpose );
    @channel_sums = @{ $a->solve()->transpose->[0] };
}

if ($print_obs) {
    for my $run (0..$n_runs-1) {
        for my $tag (keys %{$obs_mz->[$run]}) {
            my @observed_mz  = @{  $obs_mz->[$run]->{$tag} };
            my @observed_int = @{ $obs_int->[$run]->{$tag} };
            my $m = median(@observed_mz);
            my $s = mad(@observed_mz);
            my $n = scalar(@observed_mz);
            for (0..$#observed_mz) {
                my $mz  = $observed_mz[$_];
                my $int = $observed_int[$_];
                my $diff = $mz - $m;
                print "$run\t$tag\t$mz\t$diff\t$int\n";
            }
            warn "$run\t$tag\t$n\t$m\t$s\n";
        }
    }
    exit;
}

if ($recal_reporters) {
    warn "----------------------\n";
    warn "recalibrated channels:\n";
    for my $tag (@reporters) {

        my $name = $tag->{name};

        for my $run (0..$n_runs-1) {
            my @observed = @{ $obs_mz->[$run]->{$name} };
            my $stat = Statistics::Descriptive::Sparse->new();
            $stat->add_data(@observed);
            my $mean = $stat->mean;
            my $sd   = $stat->standard_deviation;
            $tag->{$run}->{center} = $mean;
            $tag->{$run}->{lower}  = $mean-$sd*6;
            $tag->{$run}->{upper}  = $mean+$sd*6;
        }
    }

    # make sure windows don't overlap (may happen for very wide tolerances)
    for my $i (0..$#reporters) {

        my $name = $reporters[$i]->{name};

        for my $run (0..$n_runs-1) {

            my $lower = $reporters[$i]->{$run}->{lower};
            my $upper = $reporters[$i]->{$run}->{upper};
            
            if ($i > 0) {
                my $mid = (
                    $reporters[$i-1]->{$run}->{center}
                  + $reporters[$i  ]->{$run}->{center} ) / 2;
                $lower = $mid if ($lower < $mid);
            }
            if ($i < $#reporters) {
                my $mid = (
                    $reporters[$i  ]->{$run}->{center}
                  + $reporters[$i+1]->{$run}->{center} ) / 2;
                $upper = $mid if ($upper > $mid);
            }

            $reporters[$i]->{$run}->{lower} = $lower;
            $reporters[$i]->{$run}->{upper} = $upper;
            warn join("\t",
                $name,
                "run $run",
                $reporters[$i]->{$run}->{center},
                $reporters[$i]->{$run}->{lower},
                $reporters[$i]->{$run}->{upper},
            ) . "\n";
        }
    }
    warn "----------------------\n";
}

if (defined $plot_reporters) {

    my $R = Statistics::R->new();

    # initialize PDF
    $R->run(qq`pdf("$plot_reporters", 11, 8.5, pointsize=11, useDingbats=F)`);
    $R->run(q`par(mfrow=c(4,5))`);
    $R->run(q`par(mgp=c(2.2,0.7,0))`);
    $R->run(q`par(mar=c(4,4,3.5,3.5))`);
    $R->run(q`par(omi=c(1,1,1,1))`);

    for my $tag (@reporters) {

        my @lowers;
        my @uppers;
        my @series;
        my $name = $tag->{name};

        for my $run (0..$n_runs-1) {
            push @lowers, $tag->{$run}->{lower};
            push @uppers, $tag->{$run}->{upper};
            push @series, $obs_mz->[$run]->{$name};
        }
        my $x_min = min( @lowers, map {@$_} @series );
        my $x_max = max( @uppers, map {@$_} @series );
            

        $R->set('xmin', $x_min);
        $R->set('xmax', $x_max);
        $R->run(q`xlo <- xmin - (xmax-xmin)*.15`);
        $R->run(q`xhi <- xmax + (xmax-xmin)*.15`);
        $R->run(q`xhi <- xmax + (xmax-xmin)*.15`);

        for (0..$#series) {
            
            $R->set('mz', $series[$_]);
            if ($_ == 0) {
                $R->run(qq`plot(density(mz),xlim=c(xlo,xhi),main="$name",xlab="m/z",ylab="density",lwd=0.5)`);
            }
            else {
                $R->run(qq`lines(density(mz),lwd=0.5)`);
            }
        }

        for (0..$#series) {

            $R->set('lower', $lowers[$_]);
            $R->set('upper', $uppers[$_]);
            $R->run(q`abline(v=lower,col="red",lwd=0.5)`);
            $R->run(q`abline(v=upper,col="red",lwd=0.5)`);

        }
    }
    for my $tag (@reporters) {

        my @lowers;
        my @uppers;
        my @mz;
        my @int;
        my $name = $tag->{name};

        for my $run (0..$n_runs-1) {
            push @lowers, $tag->{$run}->{lower};
            push @uppers, $tag->{$run}->{upper};
            push @mz, @{ $obs_mz->[$run]->{$name} };
            push @int, @{ $obs_int->[$run]->{$name} };
        }
        my $x_min = min( @lowers, @mz );
        my $x_max = max( @uppers, @mz );
            

        $R->set('mz',  \@mz);
        $R->set('int', \@int);
        $R->set('xmin', $x_min);
        $R->set('xmax', $x_max);
        $R->run(q`xlo <- xmin - (xmax-xmin)*.15`);
        $R->run(q`xhi <- xmax + (xmax-xmin)*.15`);
        $R->run(q`xhi <- xmax + (xmax-xmin)*.15`);
        $R->run(qq`smoothScatter(mz,log10(int),xlim=c(xlo,xhi),main="$name",xlab="m/z",ylab="log10 intensity")`);

        for (0..$#lowers) {

            $R->set('lower', $lowers[$_]);
            $R->set('upper', $uppers[$_]);
            $R->run(q`abline(v=lower,col="red",lwd=0.5)`);
            $R->run(q`abline(v=upper,col="red",lwd=0.5)`);

        }

    }
    $R->run(q`dev.off()`);

}    

my $total_int = sum @channel_sums;
my @scale_factors = map {$_/$total_int} @channel_sums;

print "## Produced by tmt_quant v$VERSION\n";
print "## Command-line arguments: @orig_argv\n";
print "## Final reporter windows:\n";
for my $tag (@reporters) {
    for my $run (0..$n_runs-1) {
        say "##   ", join "\t",
            $tag->{name},
            "run $run",
            $tag->{$run}->{lower},
            $tag->{$run}->{upper},
        ;
    }
}

print join "\t", qw/
    id
    probability
    peptide
    mz
    charge
    full_peptide
    protein
    coelute_inf
    is_ntagged
    tagged_Lys
    /;
say "\t", join( "\t", map {$_->{name}} @reporters );

my $n_spectra = scalar(@spectra);
my $n_passed              = 0;
my $n_empty               = 0;
my $n_failed_min_channels = 0;
my $n_failed_min_int      = 0;

SPECTRUM:
for my $spectrum (@spectra) {

    my @parts = @{$spectrum};

    my ($run, $name,$prob,$peptide,$mz,$charge,$full_peptide,$protein,$inf,$baseline,$is_ntagged,$tagged_lys)
        = splice @parts, 0, 12;
    if (! scalar(@parts)) {
        ++$n_empty;
        #warn "empty reporter window\n";
        next SPECTRUM;
    }
    die "reporter values not multiple of 2!\n" if (scalar(@parts) % 2);
    my $mid = scalar(@parts)/2;
    my @mz_reporter_win  = @parts[0..$mid-1];
    my @int_reporter_win = @parts[$mid..$#parts];
    my ($rep_mz,$rep_int) = extract_channels($run, \@mz_reporter_win, \@int_reporter_win);

    # filter by minimum number of matched channels
    if (keys %$rep_int < $min_matched) {
        #warn "Too few channels matched\n";
        ++$n_failed_min_channels;
        next SPECTRUM;
    }

    my @values = map {defined $rep_int->{$_->{name}} ? $rep_int->{$_->{name}} : $baseline} @reporters;
    if (any {$_ < $baseline} @values) {
        warn "@values less than $baseline!!!!\n";
        exit;
    }
    @values = map {$_ - $baseline} @values
        if ($subtract_baseline);
    
    if (max(@values) < $min_int) {
        #warn "below min int\n";
        ++$n_failed_min_int;
        next SPECTRUM;
    }

    next SPECTRUM if ($max_coelute && $inf > $max_coelute);

    # correct channel sums for impurities
    if (defined $impurities) {
        my $uncorrected = Math::Matrix->new([@values]);
        my $a = $impurities->concat( $uncorrected->transpose );
        @values = @{ $a->solve()->transpose->[0] };
    }

    # correct for coeluting precursors
    my @interferences = map {0} @scale_factors;
    if ($correct_coelute) {
        my $sum_interference = sum(@values) * $inf;
        @interferences = map {$_ * $sum_interference} @scale_factors;
    }

    my $print_string = "$name\t$prob\t$peptide\t$mz\t$charge\t$full_peptide\t$protein\t$inf\t$is_ntagged\t$tagged_lys";
    for (0..$#reporters) {
        my $int  = $values[$_] - $interferences[$_];
        $int = 0 if ($int < 0 && $zero_floor);
        if (defined $digits) {
            $int = sprintf "%.${digits}f", $int;
        }
        $print_string .= "\t$int";
    }
    $print_string .= "\n";
    print $print_string;

    ++$n_passed;

}

warn "Summary:\n";
warn "----------------------\n";
warn "Total spectra:        $n_spectra\n";
warn "Empty window:         $n_empty\n";
warn "Failed min channels:  $n_failed_min_channels\n";
warn "Failed min intensity: $n_failed_min_int\n";
warn "Passing spectra:      $n_passed\n";
warn "----------------------\n\n";

exit;

sub round {

    my ($val,$places) = @_;
    if ($val > 0) {
        return int($val*10**$places+0.5)/10**$places;
    }
    else {
        return -int(-$val*10**$places+0.5)/10**$places;
    }

}

sub process_psm {

    my $px_parser;
    {
        lock $pepxml;
        $px_parser = MS::Reader::PepXML->new($pepxml);
    }

    my %mzml;
    for my $run (0..$px_parser->n_lists()-1) {
        $px_parser->goto_list($run);
        my $mzml_fn = $px_parser->raw_file($run);
        if (! defined $mzml{$mzml_fn}) {
            my $mx_parser = MS::Reader::MzML->new($mzml_fn);
            $mzml{$mzml_fn} = $mx_parser;
        }
    }

    SPECTRUM:
    while (my $hit = $hit_queue->dequeue()) {
        my ($run_idx, $query_idx) = @{ $hit };

        $px_parser->goto_list($run_idx);
        my $query = $px_parser->fetch_result($query_idx);
        my $mzml_fn = $px_parser->raw_file($run_idx);
        my $mx_parser = $mzml{$mzml_fn};
        my $scan_id = $query->{spectrumNativeID};
        my $scan_num = $query->{start_scan};
        
        my $top = $query->get_hit(0);

        #filter by qval if given
        my $qval = $top->{search_score}
            // $qvals{$scan_num};

        next SPECTRUM
            if (defined $qval && $qval > $q_cutoff);

        my $scan_idx = $mx_parser->spectrum_index_by_id($scan_id);
        my $ms2 = $mx_parser->fetch_spectrum($scan_idx);

        my $inf = 'NA';

        #extract peptide and protein group string
        my $name = $query->{spectrum};
        my $z    = $query->{assumed_charge};
        my $mz   = sprintf "%0.4f", $ms2->precursor()->{mono_mz};

        my @proteins;

        my $peptide = $top->{peptide};

        my $full_peptide = $peptide;
        my $offset = 0;
        if (defined $top->{modification_info}->{mod_nterm_mass}) {
            my $tag = sprintf("n[%.0f]", $top->{modification_info}->{mod_nterm_mass});
            substr $full_peptide, 0, 0, $tag;
            $offset += length($tag);
        }
        if (defined $top->{modification_info}->{mod_aminoacid_mass}) {
            for ( sort {$a->{position} <=> $b->{position}} @{ $top->{modification_info}->{mod_aminoacid_mass} } ) {
                my $tag = sprintf("[%.0f]", $_->{mass});
                substr $full_peptide, $_->{position}+$offset, 0, $tag;
                $offset += length($tag);
            }
        }
        $full_peptide = join '.',
            $top->{peptide_prev_aa},
            $full_peptide,
            $top->{peptide_next_aa},
        ;

        my $nterm_mod = $top->{modification_info}->{mod_nterm_mass};
        my $is_ntagged = 0;
        $is_ntagged = 1 if (defined $nterm_mod
            && $nterm_mod > 230.169 && $nterm_mod < 230.172);

        my $tagged_lys = 0;
        if (defined $top->{modification_info}->{mod_aminoacid_mass}) {
            for ( @{ $top->{modification_info}->{mod_aminoacid_mass} } ) {
                ++$tagged_lys if ($_->{mass} > 357.254 && $_->{mass} < 357.260);
            }
        }

        #skip peptides with no N-term labeled and no labeled lysines
        next PEPTIDE if ($filter_unlabeled && ($is_ntagged + $tagged_lys == 0));

        my $protein = $top->{protein};
        $protein =~ s/\|/_/g;
        pos($protein) = 0;
        $protein =~ s/\.\d+$//;
        push @proteins, $protein;

        if (defined $top->{alternative_protein}) {
            for (@{ $top->{alternative_protein} }) {
                my $p = $_->{protein};
                $p =~ s/\|/_/g;
                pos($p) = 0;
                $p =~ s/\.\d+$//;
                next if ($p =~ /^$decoy_tag/);
                push @proteins, $p;
            }
        }

        $protein = join('|', sort {$a cmp $b} uniq @proteins);

        my %scores;
        for (@{ $top->{analysis_result} }) {
            my $name = $_->{analysis};
            $scores{$name} = $_->{"${name}_result"}->{probability};
        }
        my $prob = first {defined $_} ($scores{interprophet},
            $scores{peptideprophet}, '');
            
        my $inj_time = $scale_by_inj
            ? $ms2->{scanList}->{scan}->[0]->{cvParam}->{&MS_ION_INJECTION_TIME}->[0]->{value}
            : 1;
        my @mz  = @{ $ms2->mz };
        my @int = map {$_ * $inj_time} @{ $ms2->int };
        my $baseline = min @int;

        my @mz_reporter_win;
        my @int_reporter_win;
        MZ:
        for my $i (0..$#mz) {
            my $mass = $mz[$i];
            next MZ if ($mass < $REP_LOWER);
            last MZ if ($mass > $REP_UPPER);
            push @mz_reporter_win,  $mz[$i];
            push @int_reporter_win, $int[$i];
        }
        my ($rep_mz,$rep_int) = extract_channels($run_idx, \@mz_reporter_win, \@int_reporter_win);

        my @values = map {defined $rep_int->{$_->{name}} ? $rep_int->{$_->{name}} : $baseline} @reporters;

        if ($correct_coelute || $max_coelute) {

            # calculate S2I

            my $rt_m      = $ms2->rt();
            my $precursor = $ms2->precursor();

            my $iso_mz = $precursor->{iso_mz};
            my $lower  = $precursor->{iso_lower};
            my $upper  = $precursor->{iso_upper};
            my $p_mz   = $precursor->{mono_mz};
            my $charge = $precursor->{charge};

            # get survey scan
            my $scan_idx = $mx_parser->spectrum_index_by_id( $precursor->{scan_id} );
            $mx_parser->goto_spectrum( $scan_idx );
            my $ms1_e = $mx_parser->next_spectrum();
            die "failed to fetch MS1" if (! defined $ms1_e);

            my $rt_e = $ms1_e->rt();

            # calculate initial S2I
            my @mz  = @{ $ms1_e->mz };
            my @int = @{ $ms1_e->int };

            my $pre_sum = 0;
            my $all_sum = 0;
            MZ:
            for my $i (0..$#mz) {
                my $mass = $mz[$i];
                my $tol = $mass * $pre_tol / 1000000;
                my $shift = $mass * $pre_shift / 1000000;
                next MZ if ($mass < $lower - ($tol - $shift)*$fuzzy_edges);
                last MZ if ($mass > $upper + ($tol + $shift)*$fuzzy_edges);
                my $abund = $int[$i];
                my $tag = "$mass\t$abund\t$tol";
                $all_sum += $abund;

                my $proposed_H = round(($mass - $p_mz) * $charge, 0);
                my $err = $mass - ($p_mz + $proposed_H * PROTON / $charge);
                if (abs($err) <= $tol) {
                    $pre_sum += $abund;
                    $tag .= '*';
                }

            }
            my $s2i_e = ($all_sum > 0) ? $pre_sum/$all_sum : 0;
            my $s2i = $s2i_e;

            # also do following MS1 if present
            my $ms1_l;
            while ( my $scan = $mx_parser->next_spectrum() ) {
                if ($scan->ms_level() == 1) {
                    $ms1_l = $scan;
                    last;
                }
            }

            # also do following MS1 if present
            if (defined $ms1_l) {

                my $rt_l = $ms1_l->rt();

                # calculate next S2I
                my @mz  = @{ $ms1_l->mz };
                my @int = @{ $ms1_l->int };

                my $pre_sum = 0;
                my $all_sum = 0;
                MZ:
                for my $i (0..$#mz) {
                    my $mass = $mz[$i];
                    my $tol = $mass * $pre_tol / 1000000;
                    my $shift = $mass * $pre_shift / 1000000;
                    next MZ if ($mass < $lower - ($tol - $shift)*$fuzzy_edges);
                    last MZ if ($mass > $upper + ($tol + $shift)*$fuzzy_edges);
                    my $abund = $int[$i];
                    $all_sum += $abund;
                    my $tag = "$mass\t$abund\t$tol";

                    my $proposed_H = round(($mass - $p_mz) * $charge, 0);
                    my $err = $mass - ($p_mz + $proposed_H * PROTON / $charge);
                    if (abs($err) <= $tol) {
                        $pre_sum += $abund;
                        $tag .= '*';
                    }

                }
                my $s2i_l = ($all_sum > 0) ? $pre_sum/$all_sum : 0;
                $s2i = ($rt_m - $rt_e)*($s2i_l - $s2i_e)/($rt_l - $rt_e) + $s2i_e;

            }
            else {
                warn "failed to find following MS1\n";
            }

            #decontaminate
            
            $inf = 1 - $s2i;
        }

        if ($zero_floor) {
            @values = map {$_ > 0 ? $_ : 0} @values;
        }


        {
            lock $obs_mz;
            for (keys %{ $rep_mz }) {
                push @{ $obs_mz->[$run_idx]->{ $_ } },  $rep_mz->{$_};
            }
        }
        {
            lock $obs_int;
            for (keys %{ $rep_int }) {
                push @{ $obs_int->[$run_idx]->{ $_ } },  $rep_int->{$_};
            }
        }
        {
            lock @channel_sums;
            for (0..$#values) {
                    $channel_sums[$_] += $values[$_];
            }
        }
        {
            lock @spectra;
            my @sp = (
                $run_idx,
                $name,
                $prob,
                $peptide,
                $mz,
                $z,
                $full_peptide,
                $protein,
                $inf,
                $baseline,
                $is_ntagged,
                $tagged_lys,
                @mz_reporter_win,
                @int_reporter_win,
            );
            push @spectra, shared_clone([@sp]);
        }

    }
}

sub load_queue  {

    my $px_parser;
    {
        lock $pepxml;
        $px_parser = MS::Reader::PepXML->new($pepxml);
    }

    RUN:
    for my $run_idx (0..$px_parser->n_lists()-1) {
        $px_parser->goto_list($run_idx);
        SPECTRUM:
        for (0..$px_parser->result_count()-1) {
            $hit_queue->enqueue( [$run_idx, $_] );
        }
    }
    warn "done loading\n";
    $hit_queue->enqueue(undef) for (1..$threads);

}


sub extract_channels {

    my %rep_mz;
    my %rep_int;

    my ($run, $mz_ref, $int_ref) = @_;
    for my $i (0..$#{$mz_ref}) {
        my $mass = $mz_ref->[$i];
        for my $tag (@reporters) {
            if ($mass > $tag->{$run}->{lower} && $mass <= $tag->{$run}->{upper}) {
                my $int = $int_ref->[$i];
                if (defined $rep_int{$tag->{name}}) {
                    if ($int > $rep_int{$tag->{name}}) {
                        $rep_int{$tag->{name}} = $int;
                        $rep_mz{$tag->{name}}  = $mass;
                    }
                }
                else {
                    $rep_int{$tag->{name}} = $int;
                    $rep_mz{$tag->{name}}  = $mass;
                }
            }
        }
    }
    return {%rep_mz}, {%rep_int};
}

sub median {

    my (@vals) = @_;
    return if (scalar(@vals) < 1);
    @vals = sort {$a <=> $b} @vals;
    my $mid_idx = int(scalar(@vals)/2);
    return scalar(@vals) % 2
        ?  $vals[$mid_idx]
        : ($vals[$mid_idx] + $vals[$mid_idx-1])/2;

}

sub mad {

    my (@vals) = @_;
    return if (scalar(@vals) < 1);
    my $m = median(@vals);
    return median( map {abs($_-$m)} @vals );

}

sub parse_percolator {

    my $qvals;

    open my $in, '<', $fn_perc;
    my $h = <$in>;
    chomp $h;
    my @headers = split "\t", $h;

    # handle tabular output from percolator or crux-percolator
    # check for percolator output first
    my $col_idx;
    my $parse_idx = 0;
    if (defined first_index {$_ eq 'PSMId'} @headers) {
        $col_idx = $_;
        $parse_idx = 1;
    }
    elsif (defined first_index {$_ eq 'scan'} @headers) {
        $col_idx = $_;
    }
    else {
        die "Missing expected index column in percolator table";
    }
    my $col_qval;
    if (defined first_index {$_ eq 'q-value'} @headers) {
        $col_qval = $_;
    }
    else {
        die "Missing expected q-value column in percolator table";
    }
    
    # parse lines
    while (my $line = <$in>) {
        chomp $line;
        my @fields = split "\t", $line;
        my $scan = $fields[ $col_idx ];
        if ($parse_idx) {
            if ($scan =~ /_(\d+)_\d+_\d+$/) {
                $scan = $1;
            }
            else {
                die "Unexpected PSMId strint format in percolator table";
            }
        }
        $qvals->{$scan} = $fields[ $col_qval ];
    }

    return $qvals;

}

